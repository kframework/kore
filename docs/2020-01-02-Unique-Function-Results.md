Unique function results
=======================

Background
----------

Let us say that we have a `sgn` function defined in the usual way:
```
sgn(x) = -1 requires x < 0
sgn(x) = 0 requires x == 0
sgn(x) = 1 requires x > 0
```

Let us also say that we're trying to simplify this top-level configuration:
`sgn(x) and x > 0`. Then it should be obvious that this evaluates uniquely to
`1 and x > 0`, and we can solve that by passing the top-level condition,
`x > 0`, as a side condition to the function simplifier, which can then use it
to prune the unfeasible branches.

The problem
-----------

The main question is what to use as a side condition when simplifying other
predicates in a way that makes sense. The predicate can be either the
top-level one or it could be generated by something like unification or
function application simplification.

One interesting issue is how to simplify the predicate `sgn(x)==1`

Options
-------

### Use the top-level predicate

Except when simplifying the top condition, we can safely use the top-level
predicate as a side condition. When simplifying the top condition we can safely
use the previous top condition (for the first iteration we can just use `top`).
This would allow us to simplify many predicates, but would fail for `sgn(x)==1`

### Conditions as their own side conditions

We could try to use a condition as its own side-condition.

The intuition would be that, when simplifying the `sgn(x)` part from
`sgn(x) == 1 and x > 0` the SMT can use `x>0` to prune all branches except one.
When simplifying `sgn(x) == 1`, the SMT may again prune all branches except one
(assuming that it has the definition for `sgn`).

There main problem is that the side condition cannot be used to prune unneeded
predicates, which seems to be a priority right now. Normally, if the top-level
predicate is `x>0` and we evaluate `sgn(x)` to `1 and x>0`, then we can safely
drop `x>0` from the evaluation result and keep only the `1` part. If we try that
when evaluating `sgn(x)==1` with itself as a side condition we would get just
`top`, losing the `x>0` side condition.

### Combining the two

We could do a two-step simplification. If `C` is the top-level condition:

1. Let us say that a subterm `sigma` of a predicate `P` is being evaluated
   to `phi1`, `phi2`, ... Then we will filter these using `P and C and Qi` as
   side conditions, where `Qi = sigma==phii`.
2. Prune the conditions of the remaining `phii` (hopefully there is only one)
   by using `C`