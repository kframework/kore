\documentclass[12pt]{report}

\newif\ifheader
\headerfalse  % \headertrue % to print module headers with each chapter

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage[nohead]{geometry}

\usepackage{xcolor}
\definecolor{comment}{gray}{0.4}

\usepackage[colorlinks=true]{hyperref}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}  % \mathcal \mathfrak \mathit \mathsf \mathtt
\usepackage{braket}  % \bra \ket \braket \set
\usepackage{breqn}  % \begin{dmath} \begin{dgroup} \begin{dseries}

\usepackage{fontspec}
\setmonofont[Scale=0.75]{SourceCodePro}  % Should ship with TeX Live and MikTeX

\usepackage{listings}

% Define Kore Language style
\lstdefinelanguage{kore}
{
    % use /* */ for comments
    morecomment=[s]{/*}{*/},
    % regard some characters as letters
    alsoletter={-\#\\},
    % list of declaration keywords
    morekeywords=[1]{
        module,
        endmodule,
        hooked-sort,
        sort,
        symbol,
        hooked-symbol,
        alias,
        axiom,
        import,
    },
    % list of connectives
    morekeywords=[2]{
        \\not,
        \\or,
        \\implies,
        \\and,
        \\equals,
        \\exists,
        \\forall,
        \\iff
    }
}

% Haskell listing style without all the extra keywords
\lstdefinelanguage%
[light]{Haskell}%
[]{Haskell}{%
    otherkeywords={},%
    deletekeywords={%
        AbsoluteSeek,AppendMode,%
        Array,BlockBuffering,Bool,BufferMode,Char,Complex,Double,Either,%
        FilePath,Float,Int,Integer,IO,IOError,Ix,LineBuffering,Maybe,%
        Ordering,NoBuffering,ReadMode,ReadWriteMode,ReadS,RelativeSeek,%
        SeekFromEnd,SeekMode,ShowS,StdGen,String,Void,Bounded,Enum,Eq,%
        Eval,ExitCode,exitFailure,exitSuccess,Floating,Fractional,%
        Functor,Handle,HandlePosn,IOMode,Integral,List,Monad,MonadPlus,%
        MonadZero,Num,Numeric,Ord,Random,RandomGen,Ratio,Rational,Read,%
        Real,RealFloat,RealFrac,Show,System,Prelude,EQ,False,GT,Just,%
        Left,LT,Nothing,Right,WriteMode,True,abs,accum,accumArray,%
        accumulate,acos,acosh,all,and,any,ap,appendFile,applyM,%
        approxRational,array,asTypeOf,asin,asinh,assocs,atan,atan2,atanh,%
        bounds,bracket,bracket_,break,catch,catMaybes,ceiling,chr,cis,%
        compare,concat,concatMap,conjugate,const,cos,cosh,curry,cycle,%
        decodeFloat,delete,deleteBy,deleteFirstsBy,denominator,%
        digitToInt,div,divMod,drop,dropWhile,either,elem,elems,elemIndex,%
        elemIndices,encodeFloat,enumFrom,enumFromThen,enumFromThenTo,%
        enumFromTo,error,even,exitFailure,exitWith,exp,exponent,fail,%
        filter,filterM,find,findIndex,findIndices,flip,floatDigits,%
        floatRadix,floatRange,floatToDigits,floor,foldl,foldM,foldl1,%
        foldr,foldr1,fromDouble,fromEnum,fromInt,fromInteger,%
        fromIntegral,fromJust,fromMaybe,fromRat,fromRational,%
        fromRealFrac,fst,gcd,genericLength,genericTake,genericDrop,%
        genericSplitAt,genericIndex,genericReplicate,getArgs,getChar,%
        getContents,getEnv,getLine,getProgName,getStdGen,getStdRandom,%
        group,groupBy,guard,hClose,hFileSize,hFlush,hGetBuffering,%
        hGetChar,hGetContents,hGetLine,hGetPosn,hIsClosed,hIsEOF,hIsOpen,%
        hIsReadable,hIsSeekable,hIsWritable,hLookAhead,hPutChar,hPutStr,%
        hPutStrLn,hPrint,hReady,hSeek,hSetBuffering,hSetPosn,head,%
        hugsIsEOF,hugsHIsEOF,hugsIsSearchErr,hugsIsNameErr,%
        hugsIsWriteErr,id,ioError,imagPart,index,indices,init,inits,%
        inRange,insert,insertBy,interact,intersect,intersectBy,%
        intersperse,intToDigit,ioeGetErrorString,ioeGetFileName,%
        ioeGetHandle,isAlreadyExistsError,isAlreadyInUseError,isAlpha,%
        isAlphaNum,isAscii,isControl,isDenormalized,isDoesNotExistError,%
        isDigit,isEOF,isEOFError,isFullError,isHexDigit,isIEEE,%
        isIllegalOperation,isInfinite,isJust,isLower,isNaN,%
        isNegativeZero,isNothing,isOctDigit,isPermissionError,isPrefixOf,%
        isPrint,isSpace,isSuffixOf,isUpper,isUserError,iterate,ixmap,%
        join,last,lcm,length,lex,lexDigits,lexLitChar,liftM,liftM2,%
        liftM3,liftM4,liftM5,lines,listArray,listToMaybe,log,logBase,%
        lookup,magnitude,makePolar,map,mapAccumL,mapAccumR,mapAndUnzipM,%
        mapM,mapM_,mapMaybe,max,maxBound,maximum,maximumBy,maybe,%
        maybeToList,min,minBound,minimum,minimumBy,mkPolar,mkStdGen,%
        mplus,mod,msum,mzero,negate,next,newStdGen,not,notElem,nub,nubBy,%
        null,numerator,odd,openFile,or,ord,otherwise,partition,phase,pi,%
        polar,pred,print,product,properFraction,putChar,putStr,putStrLn,%
        quot,quotRem,random,randomIO,randomR,randomRIO,randomRs,randoms,%
        rangeSize,read,readDec,readFile,readFloat,readHex,readInt,readIO,%
        readList,readLitChar,readLn,readParen,readOct,readSigned,reads,%
        readsPrec,realPart,realToFrac,recip,rem,repeat,replicate,return,%
        reverse,round,scaleFloat,scanl,scanl1,scanr,scanr1,seq,sequence,%
        sequence_,setStdGen,show,showChar,showEFloat,showFFloat,%
        showFloat,showGFloat,showInt,showList,showLitChar,showParen,%
        showSigned,showString,shows,showsPrec,significand,signum,sin,%
        sinh,snd,sort,sortBy,span,split,splitAt,sqrt,stderr,stdin,stdout,%
        strict,subtract,succ,sum,system,tail,tails,take,takeWhile,tan,%
        tanh,toEnum,toInt,toInteger,toLower,toRational,toUpper,transpose,%
        truncate,try,uncurry,undefined,unfoldr,union,unionBy,unless,%
        unlines,until,unwords,unzip,unzip3,unzip4,unzip5,unzip6,unzip7,%
        userError,when,words,writeFile,zero,zip,zip3,zip4,zip5,zip6,zip7,%
        zipWith,zipWithM,zipWithM_,zipWith3,zipWith4,zipWith5,zipWith6,%
        zipWith7%
    }%
}[keywords,comments,strings]

\lstdefinestyle{block}{%
    basicstyle=\ttfamily,
    commentstyle=\itshape\color{comment},
    columns=fixed,
    keepspaces=true
}

\lstdefinestyle{inline}{%
    basicstyle=\ttfamily,
    commentstyle=\itshape\color{comment},
    columns=fixed,
    keepspaces=true
}

\lstnewenvironment{code}{\lstset{language=[light]Haskell,style=block}}{}
\lstnewenvironment{spec}{\lstset{language=[light]Haskell,style=block}}{}

\def\ie{{i.e.},\ }
\def\eg{{e.g.},\ }
\def\cf{{cf.}\ }
\def\etc{{etc.}\ }
\def\viz{{viz.}\ }
\def\etal{{\it et al.}\ }

% Define slashed ttfamily words
\newcommand{\slsh}[1]{\texttt{\fontsize{10pt}{12pt}\textbackslash{#1}}}
\newcommand{\sland}{\slsh{and}}
\newcommand{\slor}{\slsh{or}}
\newcommand{\slnot}{\slsh{not}}
\newcommand{\slimplies}{\slsh{implies}}
\newcommand{\sliff}{\slsh{iff}}
\newcommand{\slequals}{\slsh{equals}}
\newcommand{\slexists}{\slsh{exists}}
\newcommand{\slforall}{\slsh{forall}}
\newcommand{\sltop}{\slsh{top}}
\newcommand{\slbottom}{\slsh{bottom}}
\newcommand{\slceil}{\slsh{ceil}}
\newcommand{\slfloor}{\slsh{floor}}
\newcommand{\slin}{\slsh{in}}
\newcommand{\slnext}{\slsh{next}}
\newcommand{\slrewrites}{\slsh{rewrites}}

\begin{document}
\lstset{language=[light]Haskell,style=inline}

\title{Kore Simplification}
\author{%
The K Framework Team\\%
Runtime Verification, Inc.%
}
\date{}

\maketitle

\chapter{Notation}
\label{cha:notation}

In addition to the syntax of matching logic and Kore (described elsewhere),
we adopt the convention in this document that italic variables (\eg $t$, $p$, $s$) are meta-variables.

Simplification operates on \emph{program configurations},
which are the conjunction (with \wedge) of
a \emph{term} representing the user-defined state,
a \emph{predicate} representing the conditions accumulated during execution,
and a \emph{substitution} produced during rule unification.
The predicate is a matching logic predicate, \ie it reduces to $\top$ or $\bot$.
The substitution is a conjunction of predicates of the form
\(
x = \phi
\)
where $x$ is a matching logic variable and $\phi$ is any pattern.
Configurations are represented by the type \lstinline!ExpandedPattern!,
and in this document are denoted by a triple
\(
(t, p, s)
\)
where $t$ is the term, $p$ is the predicate, and $s$ is the substitution.
A configuration triple is logically equivalent to its conjunction
\(
(t \wedge p \wedge s)
\)
but we find it instructive to give a distinct syntax.

\chapter{\slor~simplification}
\label{cha:or-simplification}

\input{Or.lhs}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-engine: luatex
%%% End:
