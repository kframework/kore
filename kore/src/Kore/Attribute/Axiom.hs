{-|
Module      : Kore.Attribute.Axiom
Description : Axiom sentence attributes
Copyright   : (c) Runtime Verification, 2018
License     : NCSA
Maintainer  : thomas.tuegel@runtimeverification.com

-}

module Kore.Attribute.Axiom
    ( Axiom (..)
    , HeatCool (..)
    , ProductionID (..)
    , Priority (..)
    , Assoc (..)
    , Comm (..)
    , Unit (..)
    , Idem (..)
    , Trusted (..)
    , Concrete (..)
    , Simplification (..)
    , Overload (..)
    , SmtLemma (..)
    , Label (..)
    , SourceLocation (..)
    , Constructor (..)
    , RuleIndex (..)
    , UniqueId (..)
    , axiomSymbolToSymbolOrAlias
    ) where

import Prelude.Kore

import Control.DeepSeq
    ( NFData
    )
import qualified Control.Lens as Lens
import qualified Control.Monad as Monad
import Data.Default
    ( Default (..)
    )
import Data.Generics.Product
import Data.Proxy
import qualified Generics.SOP as SOP
import qualified GHC.Generics as GHC

import Kore.Attribute.Assoc
import Kore.Attribute.Axiom.Concrete
import Kore.Attribute.Axiom.Constructor
import Kore.Attribute.Axiom.Unit
import Kore.Attribute.Comm
import Kore.Attribute.Functional
import Kore.Attribute.HeatCool
import Kore.Attribute.Idem
import Kore.Attribute.Label
import Kore.Attribute.Overload
import Kore.Attribute.Owise
import Kore.Attribute.Parser
    ( AttributePattern
    , Attributes
    , ParseAttributes (..)
    , SymbolOrAlias
    , toAttributes
    )
import Kore.Attribute.Priority
import Kore.Attribute.ProductionID
import Kore.Attribute.RuleIndex
import Kore.Attribute.Simplification
import Kore.Attribute.SmtLemma
import Kore.Attribute.SourceLocation
import Kore.Attribute.Subsort
import Kore.Attribute.Trusted
import Kore.Attribute.UniqueId
import Kore.Debug
import Kore.Internal.Symbol
    ( Symbol (..)
    , toSymbolOrAlias
    )
import qualified SQL

{- | Attributes specific to Kore axiom sentences.
 -}
data Axiom symbol =
    Axiom
    { heatCool :: !HeatCool
    -- ^ An axiom may be denoted as a heating or cooling rule.
    , productionID :: !ProductionID
    -- ^ The identifier from the front-end identifying a rule or group of rules.
    , priority :: !Priority
    -- ^ A number associated to each rule,
    -- which specifies the order of application
    , assoc :: !Assoc
    -- ^ The axiom is an associativity axiom.
    , comm :: !Comm
    -- ^ The axiom is a commutativity axiom.
    , unit :: !Unit
    -- ^ The axiom is a left- or right-unit axiom.
    , idem :: !Idem
    -- ^ The axiom is an idempotency axiom.
    , trusted :: !Trusted
    -- ^ The claim is trusted
    , concrete :: !Concrete
    , simplification :: !Simplification
    -- ^ This is an axiom used for simplification
    -- (as opposed to, e.g., function evaluation).
    , overload :: !(Overload symbol)
    -- ^ The axiom is an overloaded-production axiom.
    , smtLemma :: !SmtLemma
    -- ^ The axiom should be sent to SMT as a lemma.
    , label :: !Label
    -- ^ The user-defined label associated with the axiom.
    , sourceLocation :: !SourceLocation
    -- ^ Source and location in the original file.
    , constructor :: !Constructor
    -- ^ Shows that this is one of the constructor axioms
    -- (e.g. no confusion, no junk)
    , functional :: !Functional
    -- ^ Shows that this is one of the functionality axioms
    , subsorts :: !Subsorts
    -- ^ Shows that this describes a subsorting axiom
    , identifier :: !RuleIndex
    -- ^ Used to identify an axiom in the repl.
    , uniqueId :: !UniqueId
    -- ^ Unique id, usually generated by the frontend on request.
    , owise :: !Owise
    -- ^ This is an owise evaluation rule.
    }
    deriving (Eq, GHC.Generic, Ord, Show)

instance SOP.Generic (Axiom symbol)

instance SOP.HasDatatypeInfo (Axiom symbol)

instance Debug symbol => Debug (Axiom symbol)

instance (Debug symbol, Diff symbol) => Diff (Axiom symbol)

instance NFData symbol => NFData (Axiom symbol)

instance Default (Axiom symbol) where
    def =
        Axiom
            { heatCool = def
            , productionID = def
            , priority = def
            , assoc = def
            , comm = def
            , unit = def
            , idem = def
            , trusted = def
            , concrete = def
            , simplification = def
            , overload = def
            , smtLemma = def
            , label = def
            , sourceLocation = def
            , constructor = def
            , functional = def
            , subsorts = def
            , identifier = def
            , uniqueId = def
            , owise = def
            }

instance ParseAttributes (Axiom SymbolOrAlias) where
    parseAttribute attr =
        typed @HeatCool (parseAttribute attr)
        Monad.>=> typed @ProductionID (parseAttribute attr)
        Monad.>=> typed @Priority (parseAttribute attr)
        Monad.>=> typed @Assoc (parseAttribute attr)
        Monad.>=> typed @Comm (parseAttribute attr)
        Monad.>=> typed @Unit (parseAttribute attr)
        Monad.>=> typed @Idem (parseAttribute attr)
        Monad.>=> typed @Trusted (parseAttribute attr)
        Monad.>=> typed @Concrete (parseAttribute attr)
        Monad.>=> typed @Simplification (parseAttribute attr)
        Monad.>=> typed @(Overload SymbolOrAlias) (parseAttribute attr)
        Monad.>=> typed @SmtLemma (parseAttribute attr)
        Monad.>=> typed @Label (parseAttribute attr)
        Monad.>=> typed @SourceLocation (parseAttribute attr)
        Monad.>=> typed @Constructor (parseAttribute attr)
        Monad.>=> typed @Functional (parseAttribute attr)
        Monad.>=> typed @Subsorts (parseAttribute attr)
        Monad.>=> typed @UniqueId (parseAttribute attr)
        Monad.>=> typed @Owise (parseAttribute attr)

instance From symbol SymbolOrAlias => From (Axiom symbol) Attributes where
    from =
        mconcat . sequence
            [ from . heatCool
            , from . productionID
            , from . priority
            , from . assoc
            , from . comm
            , from . unit
            , from . idem
            , from . trusted
            , from . concrete
            , from . simplification
            , from . overload
            , from . smtLemma
            , from . label
            , from . sourceLocation
            , from . constructor
            , from . functional
            , from . subsorts
            , from . uniqueId
            , from . owise
            ]

instance SQL.Column (Axiom SymbolOrAlias) where
    -- TODO (thomas.tuegel): Use a foreign key.
    defineColumn _ = SQL.defineColumn (Proxy @AttributePattern)
    toColumn = SQL.toColumn . toAttributes

instance SQL.Column (Axiom Symbol) where
    -- TODO (thomas.tuegel): Use a foreign key.
    defineColumn _ = SQL.defineColumn (Proxy @AttributePattern)
    toColumn = SQL.toColumn . toAttributes

axiomSymbolToSymbolOrAlias :: Axiom Symbol -> Axiom SymbolOrAlias
axiomSymbolToSymbolOrAlias axiom =
    axiom & field @"overload" Lens.%~ fmap toSymbolOrAlias
