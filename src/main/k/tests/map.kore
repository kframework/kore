module MAP

  import SET []

  sort Map{S1,S2} []

  symbol bind{S1,S2}(S1,S2) : Map{S1,S2} []

  symbol emp{S1,S2}() : Map{S1,S2} []

  symbol keys{S1,S2}(Map{S1,S2}) : Set{S1} []

  symbol merge{S1,S2}(Map{S1,S2}, Map{S1,S2}) : Map{S1,S2} []

  /* See Matching Logic paper, Section 9.2.
   * bind, emp, and keys are functional symbols.
   * merge is partial function:
   * forall m1 m2 . merge(m1, m2) = bottom
   *                \/ exists t . merge(m1, m2) = t
   * merging two binds with the same key gets bottom
   * merge(bind(X,Y),bind(X,Z)) = bottom
   */

   axiom{R,S1,S2}
     \exists{R}(
        M:Map{S1,S2},
        \equals{Map{S1,S2},R}(
           M:Map{S1,S2},
           emp{S1,S2}()))
   []

   axiom{R,S1,S2}
     \exists{R}(
        M:Map{S1,S2},
        \forall{R}(
           K:S1,
           \forall{R}(
             V:S2,
             \equals{Map{S1,S2},R}(
                bind{S1,S2}(K:S1,V:S2),
                M))))
   []

   axiom{R,S1,S2}
     \exists{R}(
        K:Set{S1},
        \forall{R}(
           M:Map{S1,S2},
           \equals{Set{S1},R}(
              K:Set{S1},
              keys{S1,S2}(M:Map{S1,S2}))))
   []


   axiom{R,S1,S2}
     \forall{R}(
        M1:Map{S1,S2},
        \forall{R}(
           M2:Map{S1,S2},
           \or{R}(
              \equals{Map{S1,S2},R}(
                 merge{Map{S1,S2}}(M1:Map{S1,S2},M2:Map{S1,S2}),
                 \bottom{Map{S1,S2}}),
              \exists{R}(
                 T:Map{S1,S2},
                 \equals{Map{S1,S2},R}(
                    T:Map{S1,S2},
                    merge{Map{S1,S2}}(M1:Map{S1,S2},M2:Map{S1,S2}))))))
   []

   // merge(empty,M) = M

   axiom{R,S1,S2}
     \forall{R}(
        M:Map{S1,S2},
        \equals{Map{S1,S2},R}(
           merge{S1,S2}(emp{S1,S2}(),M:Map{S1,S2}),
           M:Map{S1,S2}))
   []

   // merge is commutative

   axiom{R,S1,S2}
     \forall{R}(
        M1:Map{S1,S2},
        \forall{R}(
           M2:Map{S1,S2},
           \equals{Map{S1,S2},R}(
              merge{S1,S2}(M1:Map{S1,S2},M2:Map{S1,S2}),
              merge{S1,S2}(M2:Map{S1,S2},M1:Map{S1,S2}))))
   []

   // merge is associative

   axiom{R,S1,S2}
     \forall{R}(
        M1:Map{S1,S2},
        \forall{R}(
           M2:Map{S1,S2},
           \forall{R}(
              M3:Map{S1,S2},
              \equals{Map{S1,S2},R}(
                 merge{S1,S2}(merge{S1,S2}(M1:Map{S1,S2},M2:Map{S1,S2}),M3:Map{S1,S2}),
                 merge{S1,S2}(M1:Map{S1,S2},merge{S1,S2}(M2:Map{S1,S2},M3:Map{S1,S2}))))))
   []

   // merge is disjoint

   axiom{R,S1,S2}
     \forall{R}(
        K:S1,
        \forall{R}(
           V1:S2,
           \forall{R}(
              V2:S2,
              \equals{Map{S1,S2},R}(
                 merge{S1,S2}(bind{S1,S2}(K:S1,V1:S2),bind{S1,S2}(K:S1,V2:S2)),
                 \bottom{Map{S1,S2}}))))
   []

   /* lookup, update, and insert will be hooked to external libraries. */
   symbol lookup{S1,S2}(Map{S1,S2}, S1) : S2 []

   symbol update{S1,S2}(Map{S1,S2}, S1, S2) : Map{S1,S2} []

   symbol insert{S1,S2}(Map{S1,S2}, S1, S2) : Map{S1,S2} []

endmodule []
